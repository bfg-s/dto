<?php

namespace Bfg\Dto\Console;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use Symfony\Component\Finder\SplFileInfo;

class MakeDtoDocsCommans extends Command
{
    protected $signature = "make:dto-docs";

    protected $description = "Make DTO docs";

    public function handle(): void
    {
        $path = app_path('Dto');

        if (!is_dir($path)) {
            $this->error('Directory not found: ' . $path);
            return;
        }

        $files = File::allFiles($path);

        $classes = collect($files)->map(function ($file) {
            return $this->getClassNameFromFile($file);
        })->filter()->values()->map(function ($class) {
            $this->updateClassDocBlockWithReflection($class['class'], $class['doc']);
            return $class['class'];
        })->count();

        if (! $classes) {

            $this->info('No DTO classes for processing found.');
        } else {

            $this->info('Complete! ' . $classes . ' DTO classes have been processed.');
        }
    }

    protected function getClassNameFromFile(SplFileInfo $file): ?array
    {
        $class = "App\\Dto"
            . str_replace([app_path('Dto'), '/', '.php'], ['', '\\', ''], $file->getPathname());

        if (! class_exists($class)) {

            return null;
        }
        $ref = new \ReflectionClass($class);
        $doc = ($ref)->getDocComment() ?: '';
        $extendProperty = $ref->getProperty('extends');
        $extendProperty->setAccessible(true);
        $extends = $extendProperty->getValue();
        $variables = [];
        foreach ($extends as $key => $val) {
            if (is_array($val)) {
                $variables[$key] = implode('|', array_map(function ($val) {
                    return class_exists($val) || enum_exists($val) ? "\\" . $val : $val;
                }, $val));
            } else {
                $variables[$key] = class_exists($val) || enum_exists($val) ? "\\" . $val : $val;
            }
        }

        if (! $variables) {
            return null;
        }

        return [
            'class' => $class,
            'doc' => $this->updateDocBlock($doc, $variables),
        ];
    }

    protected function updateClassDocBlockWithReflection(string $className, string $docBlock): void
    {
        // Используем рефлексию, чтобы получить файл класса
        $reflection = new \ReflectionClass($className);
        $fileName = $reflection->getFileName();

        if (!$fileName || !is_file($fileName)) {
            throw new \RuntimeException("Файл класса {$className} не найден.");
        }

        // Загружаем содержимое файла
        $code = file_get_contents($fileName);

        if ($code === false) {
            throw new \RuntimeException("Не удалось загрузить содержимое файла {$fileName}.");
        }

        // Регулярное выражение для поиска докблока
        $docBlockPattern = '/\/\*\*.*?\*\//s';

        if (preg_match($docBlockPattern, $code, $matches, PREG_OFFSET_CAPTURE)) {
            // Если докблок существует, заменяем его
            $startPos = $matches[0][1];
            $endPos = $startPos + strlen($matches[0][0]);
            $code = substr_replace($code, $docBlock, $startPos, $endPos - $startPos);
        } else {
            // Если докблока нет, добавляем новый перед классом
            if (preg_match('/\bclass\s+\w+/', $code, $matches, PREG_OFFSET_CAPTURE)) {
                $classPos = $matches[0][1];
                $code = substr_replace($code, $docBlock . "\n", $classPos, 0);
            } else {
                throw new \RuntimeException("Не удалось найти объявление класса {$className}.");
            }
        }

        // Сохраняем обновлённый код в файл
        if (file_put_contents($fileName, $code) === false) {
            throw new \RuntimeException("Не удалось записать изменения в файл {$fileName}.");
        }
    }

    protected function updateDocBlock(string $code, array $properties): string
    {
        $docBlockPattern = '/\/\*\*.*?\*\//s';

        $generateDocBlock = function (array $properties) use ($code): string {
            if (empty($properties)) {
                return "/**\n * @property mixed \$autoGeneratedProperty\n */";
            }

            $docBlock = "/**\n";
            foreach ($properties as $property => $type) {
                if (! str_contains($code, "\${$property}")) {
                    $docBlock .= " * @property {$type} \${$property}\n";
                }
            }
            $docBlock .= " */";

            return $docBlock;
        };

        $newDocBlock = $generateDocBlock($properties);

        if (preg_match($docBlockPattern, $code, $matches, PREG_OFFSET_CAPTURE)) {
            $existingDocBlock = $matches[0][0];
            $startPos = $matches[0][1];
            $endPos = $startPos + strlen($existingDocBlock);

            if (!empty($properties)) {
                $updatedDocBlock = $existingDocBlock;
                foreach ($properties as $property => $type) {
                    if (! str_contains($code, "\${$property}")) {
                        $line = " * @property {$type} \${$property}";
                        if (!str_contains($updatedDocBlock, $line)) {
                            $updatedDocBlock = substr_replace(
                                $updatedDocBlock,
                                "\n{$line}",
                                strrpos($updatedDocBlock, "\n"),
                                0
                            );
                        }
                    }
                }
            } else {
                $updatedDocBlock = $existingDocBlock;
            }

            return substr_replace($code, $updatedDocBlock, $startPos, $endPos - $startPos);
        } else {
            if (preg_match('/\bclass\s+\w+/', $code, $matches, PREG_OFFSET_CAPTURE)) {
                $classPos = $matches[0][1];
                return substr_replace($code, $newDocBlock . "\n", $classPos, 0);
            } else {
                throw new \Exception("Cannot find class declaration in the file.");
            }
        }
    }
}
